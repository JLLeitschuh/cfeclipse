<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <meta http-equiv="Content-Style-Type" content="text/css">
   <script src="pages.js" type="text/javascript" language="Javascript1.2" charset="UTF-8"></script>
   <title>Returning matched subexpressions</title>
</head>
<body>
<p align="right"><p align="right"><a href="00000989.htm"><img src="images/previous.gif" width="9" height="14" border="0" alt="Previous"></a>&nbsp;&nbsp;<a href="00000991.htm"><img src="images/next.gif" width="9" height="14" border="0" alt="Next"></a>
</p></p>
<hr />
<h1>Returning matched subexpressions</h1>
<p>The <a href="00000606.htm#135102"><code>REFind</code></a> and <a href="00000607.htm#135225"><code>REFindNoCase</code></a> functions return the location in the search string of the first match of the regular expression. Even though the search string in the next example contains two matches of the regular expression, the function only returns the index of the first:</p>
<pre>&lt;cfset IndexOfOccurrence=REFind(&quot;<strong> BIG </strong>&quot;, &quot;Some BIG BIG string&quot;)&gt;
&lt;!--- The value of IndexOfOccurrence is 5 ---&gt;
</pre><p>To find all instances of the regular expression, you must call the <code>REFind</code> and <code>REFindNoCase</code> functions multiple times. </p>
<p>Both the <code>REFind</code> and <code>REFindNoCase</code> functions take an optional third parameter that specifies the starting index in the search string for the search. By default, the starting location is index 1, the beginning of the string.</p>
<p>To find the second instance of the regular expression in this example, you call <code>REFind</code> with a starting index of 8:</p>
<pre>&lt;cfset IndexOfOccurrence=REFind(&quot;<strong> BIG </strong>&quot;, &quot;Some BIG BIG string&quot;, 8)&gt;
&lt;!--- The value of IndexOfOccurrence is 9 ---&gt;
</pre><p>In this case, the function returns an index of 9, the starting index of the second string &quot; BIG &quot;.</p>
<p>To find the second occurrence of the string, you must know that the first string occurred at index 5 and that the string's length was 5. However, <code>REFind</code> only returns starting index of the string, not its length. So, you either must know the length of the matched string to call <code>REFind</code> the second time, or you must use subexpressions in the regular expression. </p>
<p>The <code>REFind</code> and <code>REFindNoCase</code> functions let you get information about matched subexpressions. If you set these functions' fourth parameter, <code>ReturnSubExpression</code>, to True, the functions return a CFML structure with two arrays, <code>pos</code> and <code>len</code>, containing the positions and lengths of text strings that match the subexpressions of a regular expression, as the following example shows:</p>
<pre>&lt;cfset sLenPos=REFind(&quot;<strong> </strong>BIG<strong> </strong>&quot;, &quot;Some BIG BIG string&quot;, 1, &quot;<strong>True</strong>&quot;)&gt;
&lt;cfoutput&gt;
<strong>   &lt;cfdump var=&quot;#sLenPos#&quot;&gt;</strong>
&lt;/cfoutput&gt;&lt;br&gt;
</pre><p>The following figure shows the output of the <code>cfdump</code> tag:</p>
<p><br />
<img src="images/regex_ou.jpg" alt="Output of the cfdump tag" border="0" hspace="0" vspace="0"/>
<br />
</p>
<p>Element one of the <code>pos</code> array contains the starting index in the search string of the string that matched the regular expression. Element one of the <code>len</code> array contains length of the matched string. For this example, the index of the first &quot; BIG &quot; string is 5 and its length is also 5. If there are no occurrences of the regular expression, the <code>pos</code> and <code>len</code> arrays each contain one element with a value of 0. </p>
<p>You can use the returned information with other string functions, such as <code>mid</code>. The following example returns that part of the search string matching the regular expression:</p>
<pre>&lt;cfset myString=&quot;Some BIG BIG string&quot;&gt;
&lt;cfset sLenPos=REFind(&quot;<strong> </strong>BIG<strong> </strong>&quot;, myString, 1, &quot;<strong>True</strong>&quot;)&gt;
&lt;cfoutput&gt;
   #mid(myString, sLenPos.pos[1], sLenPos.len[1])#
&lt;/cfoutput&gt;
</pre><p>Each additional element in the <code>pos</code> array contains the position of the first match of each subexpression in the search string. Each additional element in <code>len</code> contains the length of the subexpression's match. </p>
<p>In the previous example, the regular expression &quot; BIG &quot; contained no subexpressions. Therefore, each array in the structure returned by <code>REFind</code> contains a single element. </p>
<p>After executing the previous example, you can call <code>REFind</code> a second time to find the second occurrence of the regular expression. This time, you use the information returned by the first call to make the second: </p>
<pre>&lt;cfset newstart = sLenPos.pos[1] + sLenPos.len[1] - 1&gt;
&lt;!--- subtract 1 because you need to start at the first space ---&gt;
&lt;cfset sLenPos2=REFind(&quot;<strong> BIG </strong>&quot;, &quot;Some BIG BIG string&quot;, newstart, &quot;True&quot;)&gt;
&lt;cfoutput&gt;
   &lt;cfdump var=&quot;#sLenPos2#&quot;&gt;
&lt;/cfoutput&gt;&lt;br&gt;
</pre><p>The following figure shows the output of the <a href="00000239.htm#3765824"><code>cfdump</code></a> tag:</p>
<p><br />
<img src="images/regex_o2.jpg" alt="Output of the cfdump tag" border="0" hspace="0" vspace="0"/>
<br />
</p>
<p>If you include subexpressions in your regular expression, each element of <code>pos</code> and <code>len</code> after element one contains the position and length of the first occurrence of each subexpression in the search string. </p>
<p>In the following example, the expression [A-Za-z]+ is a subexpression of a regular expression. The first match for the expression ([A-Za-z]+)[ ]+, is &quot;is is&quot;.</p>
<pre><code>&lt;cfset </code>sLenPos<code>=REFind(&quot;([A-Za-z]+)[ ]+\1&quot;,<br />&quot;There is is a cat in in the kitchen&quot;, 1, &quot;True&quot;)&gt;</code>
&lt;cfoutput&gt;
   &lt;cfdump var=&quot;#sLenPos#&quot;&gt;
&lt;/cfoutput&gt;&lt;br&gt;
</pre><p>The following figure shows the output of the <code>cfdump</code> tag:</p>
<p><br />
<img src="images/regex_o3.jpg" alt="Output of the cfdump tag" border="0" hspace="0" vspace="0"/>
<br />
</p>
<p>The entries sLenPos.pos[1] and sLenPos.len[1] contain information about the match of the entire regular expression. The array elements sLenPos.pos[2] and sLenPos.len[2] contain information about the first subexpression (&quot;is&quot;). Because <code>REFind</code> returns information on the first regular expression match only, the <code>sLenPos</code> structure does not contain information about the second match to the regular expression, &quot;in in&quot;.</p>
<p>The regular expression in the following example uses two subexpressions. Therefore, each array in the output structure contains the position and length of the first match of the entire regular expression, the first match of the first subexpression, and the first match of the second subexpression. </p>
<pre>&lt;cfset sString = &quot;apples and pears, apples and pears, apples and pears&quot;&gt;
&lt;cfset regex = &quot;(apples) and (pears)&quot;&gt;
&lt;cfset sLenPos = REFind(regex, sString, 1, &quot;True&quot;)&gt;
&lt;cfoutput&gt;
   &lt;cfdump var=&quot;#sLenPos#&quot;&gt;
&lt;/cfoutput&gt;&lt;br&gt;&lt;br&gt;
</pre><p>The following figure shows the output of the <code>cfdump</code> tag:</p>
<p><br />
<img src="images/regex_o4.jpg" alt="Output of the cfdump tag" border="0" hspace="0" vspace="0"/>
<br />
</p>
<p>For a full discussion of subexpression usage, see the sections on <a href="00000606.htm#135102"><code>REFind</code></a> and <a href="00000607.htm#135225"><code>REFindNoCase</code></a> in the ColdFusion functions chapter in <i>CFML Reference</i>.</p>
<h2><a name="wp1111969"></a>Specifying minimal matching</h2>
<p>The regular expression quantifiers ?, *, +, {min,} and {min,max} specify a minimum and/or maximum number of instances of a given expression to match. By default, ColdFusion locates the greatest number characters in the search string that match the regular expression. This behavior is called <i>maximal matching</i>.</p>
<p>For example, you use the regular expression &quot;&lt;b&gt;(.*)&lt;/b&gt;&quot; to search the string &quot;&lt;b&gt;one&lt;/b&gt; &lt;b&gt;two&lt;/b&gt;&quot;. The regular expression &quot;&lt;b&gt;(.*)&lt;/b&gt;&quot;, matches both of the following:</p>
<ul>
<li>
   &lt;b&gt;one&lt;/b&gt;
</li>
<li>
   &lt;b&gt;one&lt;/b&gt; &lt;b&gt;two&lt;/b&gt;
</li>
</ul>
<p>By default, ColdFusion always tries to match the regular expression to the largest string in the search string. The following code shows the results of this example:</p>
<pre>&lt;cfset sLenPos=REFind(&quot;<strong>&lt;b&gt;(.*)&lt;/b&gt;</strong>&quot;, &quot;&lt;b&gt;one&lt;/b&gt; &lt;b&gt;two&lt;/b&gt;&quot;, 1, &quot;True&quot;)&gt;
&lt;cfoutput&gt;
   &lt;cfdump var=&quot;#sLenPos#&quot;&gt;
&lt;/cfoutput&gt;&lt;br&gt;
</pre><p>The following figure shows the output of the <code>cfdump</code> tag:</p>
<p><br />
<img src="images/regex_m5.jpg" alt="Output of the cfdump tag" border="0" hspace="0" vspace="0"/>
<br />
</p>
<p>Thus, the starting position of the string is 1 and its length is 21, which corresponds to the largest of the two possible matches. </p>
<p>However, sometimes you might want to override this default behavior to find the shortest string that matches the regular expression. ColdFusion includes minimal-matching quantifiers that let you specify to match on the smallest string. The following table describes these expressions:</p>
<table border="0" cellpadding="0" cellspacing="0">
  <tr>
    <th>
Expression
    </th>
    <th>
Description
    </th>
  </tr>
  <tr>
    <td>
<p>*? </p>
    </td>
    <td>
<p>minimal-matching version of *</p>
    </td>
  </tr>
  <tr bgcolor="#F8F8F8">
    <td>
<p>+?</p>
    </td>
    <td>
<p>minimal-matching version of +</p>
    </td>
  </tr>
  <tr>
    <td>
<p>?? </p>
    </td>
    <td>
<p>minimal-matching version of ?</p>
    </td>
  </tr>
  <tr bgcolor="#F8F8F8">
    <td>
<p>{min,}?</p>
    </td>
    <td>
<p>minimal-matching version of {min,}</p>
    </td>
  </tr>
  <tr>
    <td>
<p>{min,max}? </p>
    </td>
    <td>
<p>minimal-matching version of {min,max}</p>
    </td>
  </tr>
  <tr bgcolor="#F8F8F8">
    <td>
<p>{n}?</p>
    </td>
    <td>
<p>(no different from {n}, supported for notational consistency)</p>
    </td>
  </tr>
</table>

<p>If you modify the previous example to use the minimal-matching syntax, the code is as follows:</p>
<pre>&lt;cfset sLenPos=REFind(&quot;<strong>&lt;b&gt;(.*?)&lt;/b&gt;</strong>&quot;, &quot;&lt;b&gt;one&lt;/b&gt; &lt;b&gt;two&lt;/b&gt;&quot;, 1, &quot;True&quot;)&gt;
&lt;cfoutput&gt;
   &lt;cfdump var=&quot;#sLenPos#&quot;&gt;
&lt;/cfoutput&gt;&lt;br&gt;
</pre><p>The following figure shows the output of the <code>cfdump</code> tag:</p>
<p><br />
<img src="images/regex_m6.jpg" alt="Output of the cfdump tag" border="0" hspace="0" vspace="0"/>
<br />
</p>
<p>Thus, the length of the string found by the regular expression is 10, corresponding to the string &quot;&lt;b&gt;one&lt;/b&gt;&quot;.</p>


<hr />
<p align="right"><p align="right"><a href="00000989.htm"><img src="images/previous.gif" width="9" height="14" border="0" alt="Previous"></a>&nbsp;&nbsp;<a href="00000991.htm"><img src="images/next.gif" width="9" height="14" border="0" alt="Next"></a>
</p></p>
<p><a href="http://livedocs.macromedia.com/coldfusion/7/htmldocs/00000990.htm" target="mm_window">View comments in LiveDocs</a></p>
 </body>
</html>




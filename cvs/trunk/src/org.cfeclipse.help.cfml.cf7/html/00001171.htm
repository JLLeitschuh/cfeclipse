<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <meta http-equiv="Content-Style-Type" content="text/css">
   <script src="pages.js" type="text/javascript" language="Javascript1.2" charset="UTF-8"></script>
   <title>Nesting locks and avoiding deadlocks</title>
</head>
<body>
<p align="right"><p align="right"><a href="00001170.htm"><img src="images/previous.gif" width="9" height="14" border="0" alt="Previous"></a>&nbsp;&nbsp;<a href="00001172.htm"><img src="images/next.gif" width="9" height="14" border="0" alt="Next"></a>
</p></p>
<hr />
<h1>Nesting locks and avoiding deadlocks</h1>
<p>Inconsistent nesting of <a href="00000285.htm#1100787"><code>cflock</code></a> tags and inconsistent naming of locks can cause deadlocks (blocked code). If you are nesting locks, you must consistently nest <code>cflock</code> tags in the same order and use consistent lock scopes (or names).</p>
<p>A <i>deadlock</i> is a state in which no request can execute the locked section of the page. All requests to the protected section of the page are blocked until there is a time-out. The following table shows one scenario that would cause a deadlock:</p>
<table border="0" cellpadding="0" cellspacing="0">
  <tr>
    <th>
User 1
    </th>
    <th>
User 2
    </th>
  </tr>
  <tr>
    <td>
<p>Locks the Session scope.</p>
    </td>
    <td>
<p>Locks the Application scope.</p>
    </td>
  </tr>
  <tr bgcolor="#F8F8F8">
    <td>
<p>Tries to lock the Application scope, but the Application scope is already locked by User 2.</p>
    </td>
    <td>
<p>Tries to lock the Session scope, but the Session scope is already locked by User 1.</p>
    </td>
  </tr>
</table>

<p>Neither user's request can proceed, because it is waiting for the other to complete. The two are deadlocked.</p>
<p>Once a deadlock occurs, neither of the users can do anything to break the deadlock, because the execution of their requests is blocked until the deadlock is resolved by a lock time-out.</p>
<p>You can also cause deadlocks if you nest locks of different types. An example of this is nesting an exclusive lock inside a read-only lock of the same scope or same name.</p>
<p>In order to avoid a deadlock, lock code sections in a well-specified order, and name the locks consistently. In particular, if you need to lock access to the Server, Application, and Session scopes, you must do so in the following order:</p>
<ol>
<li>
   Lock the Session scope. In the <code>cflock</code> tag, specify <code>scope=&quot;Session&quot;</code>.
</li>
<li>
   Lock the Application scope. In the <code>cflock</code> tag, specify <code>scope=&quot;Application&quot;</code>.
</li>
<li>
   Lock the Server scope. In the <code>cflock</code> tag, specify <code>scope=&quot;Server&quot;</code>.
</li>
<li>
   Unlock the Server scope.
</li>
<li>
   Unlock the Application scope.
</li>
<li>
   Unlock the Session scope.
</li>
</ol>
<p><strong>Note: </strong>You can skip any pair of lock and unlock steps in the preceding list if you do not need to lock a particular scope. For example, you can omit steps 3 and 4 if you do not need to lock the Server scope.</p><h3><a name="wp1183445"></a>Copying shared variables into the Request scope</h3>
<p>You can avoid locking some shared-scope variables multiple times during a request by doing the following:</p>
<ol>
<li>
   Copy the shared-scope variables into the Request scope in code with an exclusive lock in the Application.cfc <code>onRequestStart</code> method or the Application.cfm page.
</li>
<li>
   Use the Request scope variables on your ColdFusion pages for the duration of the request.
</li>
<li>
   Copy the variables back to the shared scope in code with an exclusive lock in the Application.cfc <code>onRequestEnd</code> method on the OnRequestEnd.cfm page.
</li>
</ol>
<p>With this technique the &quot;last request wins.&quot; For example, if two requests run simultaneously, and both requests change the values of data that was copied from the shared scope, the data from the last request to finish is saved in the shared scope, and the data from the previous request is not saved.</p>
<h3><a name="wp1187801"></a>Locking application variables efficiently</h3>
<p>The need to lock application variables can reduce server performance, because all requests that use Application scope variables must wait on a single lock. This issue is a problem even for write-once read-many variables, because you still must ensure the variable exists, and possibly set the value before you can read it.</p>
<p>You can minimize this problem by using a technique such as the following to test for the existence of application variables and set them if they do not exist:</p>
<ol>
<li>
   Use an Application scope flag variable to indicate if the variable or variables are initialized. In a read-only lock, check for the existence of the flag, and assign the result to a local variable.
</li>
<li>
   Outside the <a href="00000285.htm#1100787"><code>cflock</code></a> bock, test the value of the local variable
</li>
<li>
   If it the local variable indicates that the application variables are not initialized, get an exclusive Application scope lock.
</li>
<li>
   Inside the lock, again test the Application scope flag, to make sure another page has not set the variables between step one and step four.
</li>
<li>
   If the variables are still not set, set them and set the Application scope flag to true.
</li>
<li>
   Release the exclusive lock.
</li>
</ol>
<p>The following code shows this technique:</p>
<pre>&lt;!--- Initialize local flag to false. ---&gt;
&lt;cfset app_is_initialized = False&gt;
&lt;!--- Get a readonly lock ---&gt;
&lt;cflock scope=&quot;application&quot; type=&quot;readonly&quot;&gt;
   &lt;!--- read init flag and store it in local variable ---&gt;
   &lt;cfset app_is_initialized = IsDefined(&quot;APPLICATION.initialized&quot;)&gt;
&lt;/cflock&gt;
&lt;!--- Check the local flag ---&gt;
&lt;cfif not app_is_initialized &gt;
&lt;!--- Not initialized yet, get exclusive lock to write scope ---&gt;
   &lt;cflock scope=&quot;application&quot; type=&quot;exclusive&quot;&gt;
      &lt;!--- Check nonlocal flag since multiple requests could get to the
            exclusive lock ---&gt;
      &lt;cfif not IsDefined(&quot;APPLICATION.initialized&quot;) &gt;
         &lt;!--- Do initializations ---&gt;
         &lt;cfset APPLICATION.varible1 = someValue &gt;
          ... 
         &lt;!--- Set the Application scope initialization flag ---&gt;
         &lt;cfset APPLICATION.initialized = &quot;yes&quot;&gt;
      &lt;/cfif&gt;
   &lt;/cflock&gt;
&lt;/cfif&gt;
</pre>

<hr />
<p align="right"><p align="right"><a href="00001170.htm"><img src="images/previous.gif" width="9" height="14" border="0" alt="Previous"></a>&nbsp;&nbsp;<a href="00001172.htm"><img src="images/next.gif" width="9" height="14" border="0" alt="Next"></a>
</p></p>
<p><a href="http://livedocs.macromedia.com/coldfusion/7/htmldocs/00001171.htm" target="mm_window">View comments in LiveDocs</a></p>
 </body>
</html>




<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <meta http-equiv="Content-Style-Type" content="text/css">
   <script src="pages.js" type="text/javascript" language="Javascript1.2" charset="UTF-8"></script>
   <title>Using an XML object</title>
</head>
<body>
<p align="right"><p align="right"><a href="00001511.htm"><img src="images/previous.gif" width="9" height="14" border="0" alt="Previous"></a>&nbsp;&nbsp;<a href="00001513.htm"><img src="images/next.gif" width="9" height="14" border="0" alt="Next"></a>
</p></p>
<hr />
<h1>Using an XML object</h1>
<p>Because an XML document object is represented as a structure, you can access XML document contents using either, or a combination of both, of the following ways:</p>
<ul>
<li>
   Using the element names, such as mydoc.employee.name[1]
</li>
<li>
   Using the corresponding structure entry names (that is, <code>XmlChildren</code> array entries), such as mydoc.employee.XmlChildren[1]
</li>
</ul>
<p>Similarly, you can use either, or a combination of both, of the following notation methods:</p>
<ul>
<li>
   Structure (dot) notation, such as mydoc.employee
</li>
<li>
   Associative array (bracket) notation, such as mydoc[&quot;employee&quot;] 
</li>
</ul>
<h2><a name="wp1133173"></a>Referencing the contents of an XML object</h2>
<p>Use the following rules when you reference the contents of an XML document object <i>on the right side</i> of an assignment or as a function argument:</p>
<ul>
<li>
   By default, ColdFusion ignores element name case. As a result, it considers the element name MyElement and the element name myELement to be equivalent. To make element name matching case-sensitive, specify <code>CaseSensitive=&quot;True&quot;</code> in the <a href="00000352.htm#2497244"><code>cfxml</code></a> tag, or specify <code>True</code> as a second argument in the <a href="00000670.htm#139785"><code>XmlNew</code></a> or <a href="00000671.htm#139864"><code>XmlParse</code></a> function that creates the document object.
</li>
<li>
   If your XML object is case sensitive, do not use dot notation to reference an element or attribute name. Use the name in associative array (bracket) notation, or a reference that does not use the case-sensitive name. For example, do not use names such as the following:
<pre>
MyDoc.employee.name[1]

MyDoc.employee.XmlAttributes.Version
</pre>
<p>Instead, use names such as the following:</p>
<pre>
MyDoc.xmlRoot.XmlChildren[1]
MyDoc.xmlRoot[&quot;name&quot;][1]
MyDoc.[&quot;employee&quot;][&quot;name&quot;][1]

MyDoc.xmlRoot.XmlAttributes[&quot;Version&quot;]
MyDoc[&quot;employee&quot;].XmlAttributes[&quot;Version&quot;]
</pre>
<p><strong>Caution: </strong>Because ColdFusion always treats variable names as case-insensitive, using dot notation for element and attribute names in a case sensitive XML document can generate unexpected results (such as all-uppercase variable names), exceptions, or both.</p></li>
<li>
   If your XML object is case sensitive, you cannot use dot notation to reference an element or attribute name. Use the name in associative array (bracket) notation, or a reference that does not use the case-sensitive name (such as XmlChildren[1]) instead. 
</li>
<li>
   Use an array index to specify one of multiple elements with the same name; for example, <code>#mydoc.employee.name[1] and #mydoc.employee.name[2]</code>.
<p>If you omit the array index on the last component of an element identifier, ColdFusion treats the reference as the array of all elements with the specified name. For example, <code>mydoc.employee.name</code> refers to an array of two name elements.</p>
</li>
<li>
   Use an array index into the <code>XmlChildren</code> array to specify an element without using its name; for example, <code>mydoc.XmlRoot.XmlChildren[1]</code>.
</li>
<li>
   Use associative array (bracket) notation to specify an element name that contains a period or colon; for example, <code>myotherdoc.XmlRoot[&quot;Type1.Case1&quot;]</code>.
</li>
<li>
   You can use DOM methods in place of structure entry names.
</li>
</ul>
<p>For example, the following variables all refer to the <code>XmlText</code> value &quot;Almanzo&quot; in the XML document created in <a href="00001507.htm#1127213">A simple XML document</a>:</p>
<pre>mydoc.XmlRoot.XmlChildren[1].XmlChildren[1].XmlText
mydoc.employee.name[1].first.XmlText
mydoc.employee.name[1][&quot;first&quot;].XmlText
mydoc[&quot;employee&quot;].name[1][&quot;first&quot;].XmlText
mydoc.XmlRoot.name[1].XmlChildren[1][&quot;XmlText&quot;]
</pre><p>The following variables all refer to the EmpType attribute of the first name element in the XML document created in <a href="00001507.htm#1127213">A simple XML document</a>:</p>
<pre>mydoc.employee.name[1].XmlAttributes.EmpType
mydoc.employee.name[1].XmlAttributes[&quot;EmpType&quot;]
mydoc.employee.XmlChildren[1].XmlAttributes.EmpType
mydoc.XmlRoot.name[1].XmlAttributes[&quot;EmpType&quot;]
mydoc.XmlRoot.XmlChildren[1].XmlAttributes.EmpType 
</pre><p>Neither of these lists contains a complete set of the possible combinations that can make up a reference to the value or attribute.</p>
<h2><a name="wp1133200"></a>Assigning data to an XML object</h2>
<p>When you use an XML object reference on the left side of an expression, most of the preceding rules apply to the reference <i>up to the last element</i> in the reference string. </p>
<p>For example, the rules in <a href="00001512.htm#1133173">Referencing the contents of an XML object</a> apply to mydoc.employee.name[1].first in the following expression:</p>
<pre>mydoc.employee.name[1].first.MyNewElement = XmlElemNew(mydoc, NewElement);
</pre><p>The rule for naming in case correct document objects, however, <i>applies to the full reference string</i>, as indicated by the following caution:</p>
<p><strong>Caution: </strong>Because ColdFusion always treats variable names as case insensitive, using dot notation for element and attribute names in a case-sensitive XML document can generate unexpected results (such as all-uppercase variable names), exceptions, or both. In case-sensitive XML documents, use associative array notation or DOM notation names (such as XmlRoot or XmlChldren[2]).</p><h3><a name="wp1133227"></a>Referencing the last element on the left side of an expression</h3>
<p>The following rules apply to the meaning of the last component on the left side of an expression:</p>
<ul>
<li>
   The component name is an element structure key name (XML property name), such as <code>XmlComment</code>, ColdFusion sets the value of the specified element structure entry to the value of the right side of the expression. For example, the following line sets the XML comment in the mydoc.employee.name[1].first element to &quot;This is a comment&quot;:
<pre>
mydoc.employee.name[1].first.XmlComment = &quot;This is a comment&quot;;
</pre>
</li>
<li>
   If the component name specifies an element name and does not end with a numeric index, for example <code>mydoc.employee.name</code>, ColdFusion assigns the value on the right of the expression to the first matching element. 
<p>For example, if both <code>mydoc.employee.name[1]</code> and <code>mydoc.employee.name[2]</code> exist, the following expression replaces <code>mydoc.employee.name[1]</code> with a new element named address, not an element named name:</p>
<pre>
mydoc.employee.name = XmlElemNew(mydoc, &quot;address&quot;);
</pre>
<p>After executing this line, if there had been both <code>mydoc.employee.name[1]</code> and <code>mydoc.employee.name[2]</code>, there is now only one <code>mydoc.employee.name</code> element with the contents of the original <code>mydoc.employee.name[2]</code>.</p>
</li>
<li>
   If the component name does not match an existing element, the element names on the left and right sides of the expression must match. ColdFusion creates a new element with the name of the element on the left of the expression. If the element names do not match, it generates an error.
<p>For example if there is no <code>mydoc.employee.name.phoneNumber</code> element, the following expression creates a new <code>mydoc.employee.name.phoneNumber</code> element:</p>
<pre>
mydoc.employee.name.phoneNumber = XmlElemNew(mydoc, &quot;phoneNumber&quot;);
</pre>
<p>The following expression causes an error:</p>
<pre>
mydoc.employee.name.phoneNumber = XmlElemNew(mydoc, &quot;address&quot;);
</pre>
</li>
<li>
   If the component name does not match an existing element and the component's parent or parents also do not exist, ColdFusion creates any parent nodes as specified on the left side and use the previous rule for the last element. For example, if there is no <code>mydoc.employee.phoneNumber</code> element, the following expression creates a phoneNumber element containing an AreaCode element:
<pre>
mydoc.employee.name.phoneNumber.AreaCode = XmlElemNew(mydoc, &quot;AreaCode&quot;);
</pre>
</li>
</ul>
<h3><a name="wp1205094"></a>Assigning and retrieving CDATA values</h3>
<p>To identify that element text is CDATA by putting it inside CDATA start and end marker information items, assign the text to the XmlCdata element, not the XmlText element. You must do this because ColdFusion escapes the &lt; and &gt; symbols in the element text when you assign it to an XmlText entry. You can assign a value to an element's XmlText entry <i>or</i> its XmlCdata entry, but not to both, as each assignment overwrites the other.</p>
<p>When you retrieve data from the document object, references to XmlCdata and XmlText return the same string.</p>
<p>The following example shows how ColdFusion handles CDATA text:</p>
<pre>
&lt;cfscript&gt;
	myCDATA = &quot;This is CDATA text&quot;;
	MyDoc = XmlNew();
	MyDoc.xmlRoot = XmlElemNew(MyDoc,&quot;myRoot&quot;);
	MyDoc.myRoot.XmlChildren[1] = XmlElemNew(MyDoc,&quot;myChildNodeCDATA&quot;);
	MyDoc.myRoot.XmlChildren[1].XmlCData = &quot;#myCDATA#&quot;;
&lt;/cfscript&gt;

&lt;h3&gt;Assigning a value to MyDoc.myRoot.XmlChildren[1].XmlCdata.&lt;/h3&gt;
&lt;cfoutput&gt;
	The type of element MyDoc.myRoot.XmlChildren[1] is: 
#MyDoc.myRoot.XmlChildren[1].XmlType#&lt;br&gt;
	The value when output using XmlCdata is: 
#MyDoc.myRoot.XmlChildren[1].XmlCData#&lt;br&gt;
	The value when output using XmlText is: 
#MyDoc.myRoot.XmlChildren[1].XmlText#&lt;br&gt;
&lt;/cfoutput&gt;
&lt;br&gt;
The XML text representation of Mydoc is:
&lt;cfoutput&gt;&lt;XMP&gt;#tostring(MyDoc)#&lt;/XMP&gt;&lt;/cfoutput&gt;

&lt;h3&gt;Assigning a value to MyDoc.myRoot.XmlChildren[1].XmlText.&lt;/h3&gt;
&lt;cfset MyDoc.myRoot.XmlChildren[1].XmlText = &quot;This is XML plain text&quot;&gt;
&lt;cfoutput&gt;
	The value when output using XmlCdata is: 
#MyDoc.myRoot.XmlChildren[1].XmlCData#&lt;br&gt;
	The value when output using XmlText is: 
#MyDoc.myRoot.XmlChildren[1].XmlText#&lt;br&gt;
&lt;/cfoutput&gt;
&lt;br&gt;
The XML text representation of Mydoc is:
&lt;cfoutput&gt;&lt;XMP&gt;#tostring(MyDoc)#&lt;/XMP&gt;&lt;/cfoutput&gt;
</pre>


<hr />
<p align="right"><p align="right"><a href="00001511.htm"><img src="images/previous.gif" width="9" height="14" border="0" alt="Previous"></a>&nbsp;&nbsp;<a href="00001513.htm"><img src="images/next.gif" width="9" height="14" border="0" alt="Next"></a>
</p></p>
<p><a href="http://livedocs.macromedia.com/coldfusion/7/htmldocs/00001512.htm" target="mm_window">View comments in LiveDocs</a></p>
 </body>
</html>




<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <meta http-equiv="Content-Style-Type" content="text/css">
   <script src="pages.js" type="text/javascript" language="Javascript1.2" charset="UTF-8"></script>
   <title>Working with arguments and variables in functions</title>
</head>
<body>
<p align="right"><p align="right"><a href="00001007.htm"><img src="images/previous.gif" width="9" height="14" border="0" alt="Previous"></a>&nbsp;&nbsp;<a href="00001009.htm"><img src="images/next.gif" width="9" height="14" border="0" alt="Next"></a>
</p></p>
<hr />
<h1>Working with arguments and variables in functions</h1>
<p>This section describes the following topics:</p>
<ul>
<li>
   <a href="00001008.htm#1195203">Good argument naming practice</a>
</li>
<li>
   <a href="00001008.htm#1194483">Passing arguments</a>
</li>
<li>
   <a href="00001008.htm#1194509">Passing complex data</a>
</li>
<li>
   <a href="00001008.htm#1193923">About the Arguments scope</a>
</li>
<li>
   <a href="00001009.htm#1194372">Function-only variables</a>
</li>
<li>
   <a href="00001010.htm#1103038">Referencing caller variables</a>
</li>
<li>
   <a href="00001011.htm#1168088">Using arguments</a>
</li>
</ul>
<h2><a name="wp1195203"></a>Good argument naming practice</h2>
<p>An argument's name should represent its use. For example, the following code is unlikely to result in confusion:</p>
<pre>&lt;cfscript&gt;
   function SumN(Addend1,Addend2)
   { return Addend1 + Addend2; }
&lt;/cfscript&gt;
&lt;cfset x = 10&gt;
&lt;cfset y = 12&gt;
&lt;cfoutput&gt;#SumN(x,y)#&lt;/cfoutput&gt;
</pre><p>The following, similar code is more likely to result in programming errors:</p>
<pre>&lt;cfscript&gt;
   function SumN(x,y)
   { return x + y; }
&lt;/cfscript&gt;
&lt;cfset x = 10&gt;
&lt;cfset y = 12&gt;
&lt;cfoutput&gt;#SumN(x,y)#&lt;cfoutput&gt;
</pre><h2><a name="wp1194483"></a>Passing arguments</h2>
<p>ColdFusion passes the following data types to the function by value: </p>
<ul>
<li>
   Integers
</li>
<li>
   Real numbers
</li>
<li>
   Strings (including lists)
</li>
<li>
   Date-time objects
</li>
<li>
   Arrays
</li>
</ul>
<p>As a result, any changes that you make in the function to these arguments do not affect the variable that was used to call the function, even if the calling code is on the same ColdFusion page as the function definition. </p>
<p>ColdFusion passes queries, structures, and external objects such as COM objects into the function by reference. As a result, any changes to these arguments in the function also change the value of the variable in the calling code. </p>
<p>For an example of the effects of passing arguments, see <a href="00001008.htm#1194509">Passing complex data</a>.</p>
<h2><a name="wp1194509"></a>Passing complex data</h2>
<p>Structures, queries, and complex objects such as COM objects are passed to UDFs by reference, so the function uses the same copy of the data as the caller. Arrays are passed to user-defined functions by value, so the function gets a new copy of the array data and the array in the calling page is unchanged by the function. As a result, you must handle arrays differently from all other complex data types.</p>
<h3><a name="wp1194511"></a>Passing structures, queries, and objects</h3>
<p>For your function to modify the caller's copy of a structure, query, or object, you must pass the variable as an argument. Because the function gets a reference to the caller's structure, the caller variable reflects all changes in the function. You do not have to return the structure to the caller. After the function returns, the calling page accesses the changed data by using the structure variable that it passed to the function.</p>
<p>If you do not want a function to modify the caller's copy of a structure, query, or object, use the <a href="00000456.htm#1104156"><code>Duplicate</code></a> function to make a copy and pass the copy to the function.</p>
<h3><a name="wp1194517"></a>Passing arrays</h3>
<p>If you want your function to modify the caller's copy of the array, the simplest solution is to pass the array to the function and return the changed array to the caller in the function <code>return</code> statement. In the caller, use the same variable name in the function argument and return variable. </p>
<p>The following example shows how to directly pass and return arrays. In this example, the <code>doubleOneDArray</code> function doubles the value of each element in a one-dimensional array. </p>
<pre>&lt;cfscript&gt;
//Initialize some variables
//This creates a simple array.
a=ArrayNew(1);
a[1]=2;
a[2]=22;
//Define the function.
function doubleOneDArray(OneDArray)&#160;{
   var i = 0;
   for ( i = 1; i LE arrayLen(OneDArray); i = i + 1)
      { OneDArray[i] = OneDArray[i] * 2; }
   return OneDArray;
}
//Call the function.
a = doubleOneDArray(a);
&lt;/cfscript&gt;
&lt;cfdump var=&quot;#a#&quot;&gt;
</pre><p>This solution is simple, but it is not always optimal:</p>
<ul>
<li>
   This technique requires ColdFusion to copy the entire array twice, once when you call the function and once when the function returns. This is inefficient for large arrays and can reduce performance, particularly if the function is called frequently.
</li>
<li>
   You can use the return value for other purposes, such as a status variable.
</li>
</ul>
<p>If you do not use the <code>return</code> statement to return the array to the caller, you can pass the array as an element in a structure and change the array values inside the structure. Then the calling page can access the changed data by using the structure variable it passed to the UDF.</p>
<p>The following code shows how to rewrite the previous example using an array in a structure. It returns True as a status indicator to the calling page and uses the structure to pass the array data back to the calling page.</p>
<pre>&lt;cfscript&gt;
//Initialize some variables.
//This creates an simple array as an element in a structure.
arrayStruct=StructNew();
arrayStruct.Array=ArrayNew(1);
arrayStruct.Array[1]=2;
arrayStruct.Array[2]=22;
//Define the function.
function doubleOneDArrayS(OneDArrayStruct)&#160;{
   var i = 0;
   for ( i = 1; i LE arrayLen(OneDArrayStruct.Array); i = i + 1)
      { OneDArrayStruct.Array[i] = OneDArrayStruct.Array[i] * 2; }
   return True;
}
//Call the function.
Status = doubleOneDArrayS(arrayStruct);
WriteOutput(&quot;Status: &quot; &amp; Status);
&lt;/cfscript&gt;
&lt;/br&gt;
&lt;cfdump var=&quot;#arrayStruct#&quot;&gt;
</pre><p>You must use the same structure element name for the array (in this case Array) in the calling page and the function.</p>
<h2><a name="wp1193923"></a>About the Arguments scope</h2>
<p>All function arguments exist in their own scope, the Arguments scope. </p>
<p>The Arguments scope exists for the life of a function call. When the function returns, the scope and its variables are destroyed. </p>
<p>However, destroying the Argument scope does not destroy variables, such as structures or query objects, that ColdFusion passes to the function by reference. The variables on the calling page that you use as function arguments continue to exist; if the function changes the argument value, the variable in the calling page reflects the changed value.</p>
<p>The Arguments scope is special, in that you can treat the scope as either an array <i>or</i> a structure. This dual nature of the Arguments scope is useful because it makes it easy to use arguments in any of the following circumstances: </p>
<ul>
<li>
   You define the function using CFScript.
</li>
<li>
   You define the function using the <a href="00000263.htm#2852457"><code>cffunction</code></a> tag.
</li>
<li>
   You pass arguments using argument name=value format.
</li>
<li>
   You pass arguments as values only.
</li>
<li>
   The function takes optional, undeclared arguments.
</li>
</ul>
<p>The following sections describe the general rules for using the Arguments scope as an array and a structure. For more information on using the Arguments scope in functions defined using CFScript, see <a href="00001008.htm#1166570">Using the Arguments scope in CFScript</a>. For more information on using the Arguments scope in functions defined using the <code>cffunction</code> tag, see <a href="00001008.htm#1163335">Using the Arguments scope in cffunction definitions</a>.</p>
<h3><a name="wp1193946"></a>The contents of the Arguments scope</h3>
<p>The following rules apply to the Arguments scope and its contents:</p>
<ul>
<li>
   The scope contains all the arguments passed into a function. 
</li>
<li>
   If you use <code>cffunction</code> to define the function, the scope always contains an entry &quot;slot&quot; for each declared argument, even if you do not pass the argument to the function when you call it. If you do not pass a declared (optional) argument, the scope entry for that argument is empty.
<p>When you call a function that you defined using CFScript, you must pass the function a value for each argument declared in the function definition. Therefore, the Arguments scope for a CFScript call does not have empty slots.</p>
</li>
</ul>
<p>The following example shows these rules. Assume that you have a function declared, as follows:</p>
<pre>&lt;cffunction name=&quot;TestFunction&quot;&gt;
   &lt;cfargument name=&quot;Arg1&quot; &gt;
   &lt;cfargument name=&quot;Arg2&quot;&gt;
&lt;/cffunction&gt;   
</pre><p>You can call this function with a single argument, as in the following line:</p>
<pre>&lt;cfset TestFunction(1)&gt;
</pre><p>The resulting Arguments scope looks like the following:</p>
<table border="0" cellpadding="0" cellspacing="0">
  <tr>
    <th colspan="2" rowspan="1">
As an array
    </th>
    <th colspan="2" rowspan="1">
As a structure
    </th>
  </tr>
  <tr>
    <th>
Entry
    </th>
    <th>
Value
    </th>
    <th>
Entry
    </th>
    <th>
Value
    </th>
  </tr>
  <tr bgcolor="#F8F8F8">
    <td>
<p>1</p>
    </td>
    <td>
<p>1</p>
    </td>
    <td>
<p>Arg1</p>
    </td>
    <td>
<p>1</p>
    </td>
  </tr>
  <tr>
    <td>
<p>2</p>
    </td>
    <td>
<p>undefined</p>
    </td>
    <td>
<p>Arg2</p>
    </td>
    <td>
<p>undefined</p>
    </td>
  </tr>
</table>

<p>In this example, the following functions return the value 2 because there are two defined arguments:</p>
<pre>ArrayLen(Arguments)
StructCount(Arguments)
</pre><p>However, the following tests return the value False, because the contents of the second element in the Arguments scope is undefined.</p>
<pre>Isdefined(&quot;Arguments.Arg2&quot;)
testArg2 = Arguments[2]&gt;
Isdefined(&quot;testArg2&quot;)
</pre><p><strong>Note: </strong>The <a href="00000520.htm#1106482"><code>IsDefined</code></a> function does not test the existence of array elements. Instead, put any code that might try to access an undefined array element in a try block and use a catch block to handle exceptions that arise if elements do not exist. </p><h4><a name="wp1194005"></a>Using the Arguments scope as an array</h4>
<p>The following rules apply to referencing Arguments scope as an array:</p>
<ul>
<li>
   If you call the function using unnamed arguments, the array index is the position of the argument in the function call. 
</li>
<li>
   If you use names to pass the arguments, the array indexes correspond to the order in which the arguments are declared in the function definition.
</li>
<li>
   If you use names to pass arguments, and do not pass all the arguments defined in the function, the Arguments array has an empty entry at the index corresponding to the argument that was not passed. This rule applies only to functions created using the <code>cffunction</code> tag.
</li>
<li>
   If you use a name to pass an optional argument that is not declared in the function definition, the array index of the argument is the sum of the following:
<ol><li>The number of arguments defined with names in the function.</li><li>The position of the optional argument among the arguments passed in that do not have names defined in the function. </li><p>However, using argument names in this manner is not good programming practice because you cannot ensure that you always use the same optional argument names when calling the function.</p>
</ol></li>
</ul>
<p>To demonstrate these rules, define a simple function that displays the contents of its Arguments array and call the function with various argument combinations, as shown in the following example:</p>
<pre>&lt;cffunction name=&quot;TestFunction&quot; &gt;
   &lt;cfargument name=&quot;Arg1&quot;&gt;
   &lt;cfargument name=&quot;Arg2&quot;&gt;
   &lt;cfloop index=&quot;i&quot; from=&quot;1&quot; to=&quot;#ArrayLen(Arguments)#&quot;&gt;
      &lt;cfoutput&gt;Argument #i#: #Arguments[i]#&lt;br&gt;&lt;/cfoutput&gt;
   &lt;/cfloop&gt;
&lt;/cffunction&gt;   

&lt;strong&gt;One Unnamed argument&lt;/strong&gt;&lt;br&gt;
&lt;cfset TestFunction(1)&gt;
&lt;strong&gt;Two Unnamed arguments&lt;/strong&gt;&lt;br&gt;
&lt;cfset TestFunction(1, 2)&gt;
&lt;strong&gt;Three Unnamed arguments&lt;/strong&gt;&lt;br&gt;
&lt;cfset TestFunction(1, 2, 3)&gt;
&lt;strong&gt;Arg1:&lt;/strong&gt;&lt;br&gt;
&lt;cfset TestFunction(Arg1=8)&gt;
&lt;strong&gt;Arg2:&lt;/strong&gt;&lt;br&gt;
&lt;cfset TestFunction(Arg2=9)&gt;
&lt;strong&gt;Arg1=8, Arg2=9:&lt;/strong&gt;&lt;br&gt;
&lt;cfset TestFunction(Arg1=8, Arg2=9)&gt;
&lt;strong&gt;Arg2=6, Arg1=7&lt;/strong&gt;&lt;br&gt;
&lt;cfset TestFunction(Arg2=6, Arg1=7)&gt;
&lt;strong&gt;Arg1=8, Arg2=9, Arg3=10:&lt;/strong&gt;&lt;br&gt;
&lt;cfset TestFunction(Arg1=8, Arg2=9, Arg3=10)&gt;
&lt;strong&gt;Arg2=6, Arg3=99, Arg1=7&lt;/strong&gt;&lt;br&gt;
&lt;cfset TestFunction(Arg2=6, Arg3=99, Arg1=7)&gt;
</pre><p><strong>Note: </strong>Although you can use the Arguments scope as an array, the <code>IsArray(Arguments)</code> function always returns false and the <a href="00000239.htm#3765824"><code>cfdump</code></a> tag displays the scope as a structure.</p><h4><a name="wp1194047"></a>Using the Arguments scope as a structure</h4>
<p>The following rule applies when referencing Arguments scope as a structure:</p>
<ul>
<li>
   Use the argument names as structure keys. For example, if your function definition includes a Principal argument, refer to the argument as Arguments.Principal.
</li>
</ul>
<p>The following rules are also true, but <i>avoid writing code that uses them</i>. To ensure program clarity, only use the Arguments structure for arguments that you name in the function definition. Use the Arguments scope as an array for optional arguments that you do not declare in the function definition.</p>
<ul>
<li>
   If the function can take unnamed optional arguments, use array notation to reference the unnamed arguments. For example, if the function declaration includes two named arguments and you call the function with three arguments, refer to the third argument as Arguments[3]. To determine if an unnamed optional argument exists, use the <code>StructKeyExists</code> function; for example, <code>structKeyExists(Arguments,&quot;3&quot;)</code>.
</li>
<li>
   If you do not name an optional argument in the function definition, but do use a name for it in the function call, use the name specified in the function call For example, if you have an unnamed optional argument and call the function using the name myOptArg for the argument, you can refer to the argument as Arguments.myOptArg in the function body. This usage, however, is poor programming practice, as it makes the function definition contents depend on variable names in the code that calls the function.
</li>
</ul>
<h3><a name="wp1166570"></a>Using the Arguments scope in CFScript</h3>
<p>A function can have optional arguments that you do not have to specify when you call the function. To determine the number of arguments passed to the function, use the following function:</p>
<pre><code>ArrayLen(Arguments)</code>
</pre><p>When you define a function using CFScript, the function must use the Arguments scope to retrieve the optional arguments. For example, the following SumN function adds two or more numbers together. It requires two arguments and supports any number of additional optional arguments. You can refer to the first two, required, arguments as <code>Arg1</code> and <code>Arg2</code> or as <code>Arguments[1]</code> and <code>Arguments[2]</code>. You must refer to the third, fourth, and any additional optional arguments as <code>Arguments[3]</code>, <code>Arguments[4],</code> and so on. </p>
<pre>function SumN(Arg1,Arg2)&#160;{
   var arg_count = ArrayLen(Arguments);
   var sum = 0;
   var i = 0;
   for( i = 1 ; i LTE arg_count; i = i + 1 )
   {
      sum = sum + Arguments[i];
   }
   return sum; 
} 
</pre><p>With this function, any of the following function calls are valid:</p>
<pre>SumN(Value1, Value2)
SumN(Value1, Value2, Value3)
SumN(Value1, Value2, Value3, Value4)
</pre><p>and so on. </p>
<p>The code never uses the Arg1 and Arg2 argument variables directly, because their values are always the first two elements in the Arguments array and it is simpler to step through the array. Specifying Arg1 and Arg2 in the function definition ensures that ColdFusion generates an error if you pass the function one or no arguments.</p>
<p><strong>Note: </strong>Avoid referring to a required argument in the body of a function by both the argument name and its place in the Arguments scope array or structure, as this can be confusing and makes it easier to introduce errors. </p><p>For more information on the Arguments scope, see <a href="00001008.htm#1193923">About the Arguments scope</a>.</p>
<h3><a name="wp1163335"></a>Using the Arguments scope in cffunction definitions</h3>
<p>When you define a function using the <a href="00000263.htm#2852457"><code>cffunction</code></a> tag, you generally refer to the arguments directly by name if all arguments are named in the <code>cfargument</code> tags. If you do use the Arguments scope identifier, follow the rules listed in <a href="00001008.htm#1193923">About the Arguments scope</a>. </p>


<hr />
<p align="right"><p align="right"><a href="00001007.htm"><img src="images/previous.gif" width="9" height="14" border="0" alt="Previous"></a>&nbsp;&nbsp;<a href="00001009.htm"><img src="images/next.gif" width="9" height="14" border="0" alt="Next"></a>
</p></p>
<p><a href="http://livedocs.macromedia.com/coldfusion/7/htmldocs/00001008.htm" target="mm_window">View comments in LiveDocs</a></p>
 </body>
</html>



